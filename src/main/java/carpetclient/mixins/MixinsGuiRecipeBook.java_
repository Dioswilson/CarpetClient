package carpetclient.mixins;

import net.minecraft.client.Minecraft;
import net.minecraft.inventory.InventoryCrafting;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Overwrite;
import org.spongepowered.asm.mixin.Shadow;

import java.util.List;
import com.google.common.collect.Lists;
import it.unimi.dsi.fastutil.ints.IntList;
import it.unimi.dsi.fastutil.ints.IntListIterator;
import it.unimi.dsi.fastutil.ints.IntArrayList;

import net.minecraft.client.gui.recipebook.GuiRecipeBook;
import net.minecraft.inventory.InventoryCraftResult;
import net.minecraft.item.crafting.IRecipe;
import net.minecraft.inventory.Slot;
import net.minecraft.item.ItemStack;
import net.minecraft.client.util.RecipeItemHelper;
import net.minecraft.network.play.client.CPacketRecipePlacement;
import net.minecraft.inventory.ClickType;
import net.minecraft.client.gui.GuiScreen;

/*
 Overriding for adding quick crafting.

 First edit to Carpet Client, lazy mans mixen override into vanilla code.
 Overriding method func_193950_a to edit in a few lines.
 */
@Mixin(GuiRecipeBook.class)
public abstract class MixinsGuiRecipeBook {

    @Shadow private InventoryCrafting craftingSlots;
    @Shadow private Minecraft mc;
    @Shadow private RecipeItemHelper stackedContents;

    @Shadow private int getStackSize(int p_193943_1_, boolean p_193943_2_) { return 0; };
    @Shadow private List<CPacketRecipePlacement.ItemMove> clearCraftingGrid(InventoryCraftResult p_193954_1_) { return null; };
    @Shadow private void placeRecipe(IRecipe p_193013_1_, List<Slot> p_193013_2_, int p_193013_3_, IntList p_193013_4_, List<CPacketRecipePlacement.ItemMove> p_193013_5_) {};

    // Dirty override for the sake of getting started.
    @Overwrite
    private void handleRecipeClicked(IRecipe p_193950_1_, List<Slot> p_193950_2_, int p_193950_3_, InventoryCraftResult p_193950_4_){
        boolean flag = p_193950_1_.matches(this.craftingSlots, this.mc.world);
        int i = this.stackedContents.getBiggestCraftableStack(p_193950_1_, (IntList)null);

        if (flag)
        {
            boolean flag1 = true;

            for (int j = 0; j < this.craftingSlots.getSizeInventory(); ++j)
            {
                ItemStack itemstack = this.craftingSlots.getStackInSlot(j);

                if (!itemstack.isEmpty() && i > itemstack.getCount())
                {
                    flag1 = false;
                }
            }

            if (flag1)
            {
                return;
            }
        }

        int i1 = this.getStackSize(i, flag);
        IntList intlist = new IntArrayList();

        if (this.stackedContents.canCraft(p_193950_1_, intlist, i1))
        {
            int j1 = i1;
            IntListIterator lvt_10_1_ = intlist.iterator();

            while (lvt_10_1_.hasNext())
            {
                int k = ((Integer)lvt_10_1_.next()).intValue();
                int l = RecipeItemHelper.unpack(k).getMaxStackSize();

                if (l < j1)
                {
                    j1 = l;
                }
            }

            if (this.stackedContents.canCraft(p_193950_1_, intlist, j1) )
            {
                List<CPacketRecipePlacement.ItemMove> list2 = this.clearCraftingGrid(p_193950_4_);
                List<CPacketRecipePlacement.ItemMove> list3 = Lists.<CPacketRecipePlacement.ItemMove>newArrayList();
                this.placeRecipe(p_193950_1_, p_193950_2_, j1, intlist, list3);
                this.mc.playerController.handleRecipePlacement(p_193950_3_, list2, list3, this.mc.player);
                this.mc.player.inventory.markDirty();
                if (GuiScreen.isShiftKeyDown() && GuiScreen.isAltKeyDown() ){
                    this.mc.playerController.windowClick(p_193950_3_, 0, 1, ClickType.QUICK_MOVE, this.mc.player);
                }else if(GuiScreen.isShiftKeyDown() && GuiScreen.isCtrlKeyDown() ){
                    this.mc.playerController.windowClick(p_193950_3_, 0, 1, ClickType.THROW, this.mc.player);
                }
            }
        }

    }
}